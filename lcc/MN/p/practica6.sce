/*1

a) a)
 

Vemos que la matriz NO es simetrica, por lo que podemos tener autovalores imaginarios.
Para obtener una buena cota, viendo que la matriz es a coeficientes reales podemos utilizar el Corolario 1.

Análisis por filas:

C1:
r1 = 0 , centrado en (1,0)

Podemos decir entonces que un autovalor posible es 1.

C2:
r2 = 2, centrado en (0,0)

Podemos decir entonces que las componentes reales e imaginarias están en 
un círculo de radio 2 con centro en (0,0).

C3:
r3 = 2, centrado en (2,0)

Si unimos los 3 círculos, podemos ver que las componentes reales e imaginarias están en
un círculo de radio 2 con centro en (0,0) o en un círculo de radio 2 con centro en (2,0)

Análisis por columna:
C1':
r1'=2, centrado en (1,0)

C2':
r2'=1, centrado en (0,0)

C3':
r3'=1, centrado en (2,0)

Si unimos los 3 círculos, podemos ver que las componentes reales e imaginarias están
en alguno de las 3 cotas mencionadas.

Para mayor precisión, podemos intersecar los C1 U C2 U C3 con C1' U C2' U C3' obteniendo que las coordenadas
de los autovalores se encuentran en la interseccion de la union de esos círculos.
GRAFICO.

a) b)
Vemos que la matriz no es simétrica, por lo que procedemos por el corolario 1 y hacemos los correspondientes análisis:

Análisis por filas:

C1:
r1 = 0, centrado en (1,0)

C2:
r2 = 0.2, centrado en (0,0)

C3:
r3 = 0.2, centrado en (2,0)

Si unimos los 3 círculos, podemos ver que un autovalor posible es el (1,0)
o los puntos en la unión de los circulos C2 y C3.

Análisis por columnas:
C1':
r1' = 0.2, centrado en (1,0)

C2':
r2'= 0.1, centrado en (0,0)

C3':
r3' = 0.1, centrado en (2,0)

Si unimos los 3 círculos, las coordenadas de los autovalores pueden estar
en cualquiera de los 3 circulos C1', C2' o C3'.

Para mayor precisión, podemos intersecar los C1 U C2 U C3 con C1' U C2' U C3' obteniendo que las coordenadas
de los autovalores se encuentran en la interseccion de la union de esos círculos.

a) c)

Vemos que la matriz NO es simetrica, por lo que podemos tener autovalores imaginarios.
Para obtener una buena cota, viendo que la matriz es a coeficientes reales podemos utilizar el Corolario 1.

Análisis por filas:

C1:
r1 = 0 , centrado en (1,0)

Podemos decir entonces que un autovalor posible es 1.

C2:
r2 = 0.5, centrado en (0,0)

C3:
r3 = 0.5, centrado en (2,0)

Si unimos los 3 círculos, las coordenadas de los autovalores pueden estar en cualquiera de los 3 círculos
C1, C2, C3
Anásis por columnas:

C1':
r1' = 0.5, centrado en (1,0)

C2':
r2' = 0.25, centrado en (0,0)

C3':
r3' = 0.25, centrado en (2,0)


a
Si unimos los 3 círculos, las coordenadas de los autovalores pueden estar
en cualquiera de los 3 circulos C1', C2' o C3'.

Para mayor precisión, podemos intersecar los C1 U C2 U C3 con C1' U C2' U C3' obteniendo que las coordenadas
de los autovalores se encuentran en la interseccion de la union de esos círculos.

a) d)

Vemos que la matriz no es simétrica.

Análisis por filas:

C1:
r1 = 1, centrado en (4,0)

C2:
r2 = 2, centrado en (4,0)

C3:
r3 = 2, centrado en (4,0)

Si unimos los 3 circulos, vemos que los autovalores poseen coordenadas dentro del círculo de radio 2 centrado en (4,0)

Análisis por columna:

C1'
r1' = 2, centrado en (4,0)

C2':
r2' = 2, centrado en (4,0)

C3':
r3' = 1, centrado en (4,0)

Si unimos los 3 circulos, vemos que los autovalores poseen coordenadas dentro del círculo de radio 2 centrado en (4,0).

Podemos intersecar los C1 U C2 U C3 con C1' U C2' U C3' obteniendo que las coordenadas
de los autovalores se encuentran en un círculo de radio 2 centrado en (4,0)

a) e)

Vemos que la matriz es simétrica, por lo que procedemos a realizar el análisis por filas:

C1:
r1 = 3, centrado en (3, 0)

C2:
r2 = 2, centrado en (3, 0)

C3:
r3 = 1, centrado en (3, 0)

Dado que solo tenemos autovalores reales, podemos ver que el C1 abarca los otros dos círculos,
por lo tanto sabemos que 0 <= lambda >= 6



a) f)
Vemos que la matriz es simétrica, por lo que procedemos a realizar el análisis por filas:

C1:
r1 = 2.5, centrado en (4.75,0)

C2:
r2 = 3.5, centrado en (4.75,0)

C3:
r3 = 1.5, centrado (4.75, 0)

Dado que solo tenemos autovalores reales, podemos ver que el C2 abarca los otros dos círculos,
por lo tanto => 1.25 <= lambda <= 8.25

b) a)

A = [1 0 0; -1 0 1; -1 -1 2]
A  = 

   1.   0.   0.
  -1.   0.   1.
  -1.  -1.   2.

spec(A)
 ans  =

   1.  
   1.  
   1.  

b) b)
B = [1 0 0; -0.1 0 0.1;-0.1 -0.1 2]
 B  = 

   1.    0.    0. 
  -0.1   0.    0.1
  -0.1  -0.1   2.

  spec(B)
 ans  =

   1.9949874  
   0.0050126  
   1.  

b) c)
C = [1 0 0; -0.25 0 0.25; -0.25 -0.25 2]
 C  = 

   1.     0.     0.  
  -0.25   0.     0.25
  -0.25  -0.25   2.  

 spec(C)
 ans  =

   1.9682458  
   0.0317542  
   1.  

b) d)
D = [4 -1 0;-1 4 -1;-1 -1 4]

D  = 

   4.  -1.   0.
  -1.   4.  -1.
  -1.  -1.   4.


spec(D)
 ans  =

   4.618034  
   2.381966  
   5.  

b) e)
E = [3 2 1;2 3 0;1 0 3]

 E  = 

   3.   2.   1.
   2.   3.   0.
   1.   0.   3.


--> spec(E)
 ans  =

   0.763932
   3.
   5.236068

b) f)
F = [4.75 2.25 -0.25;2.25 4.75 1.25;-0.25 1.25 4.75]
 F  = 

   4.75   2.25  -0.25
   2.25   4.75   1.25
  -0.25   1.25   4.75


--> spec(F)
 ans  =

   2.0646374
   4.9616991
   7.2236635
2)
No se entrega
---------------------------TODO-------------------------------------------------

3)
No se entrega
i)

A = [1 -1 0;-2 4 -2;0 -1 1]
AUX = zeros(3,3)
for i=0:10
    AUX(3,3) = 0.1*i
    polC= poly(A+AUX,'x')
    rices = roots(polC)
    //disp(i)
    //disp(AUX)
    disp(raices)
end

//ii)

disp("ii)")
A = [1 -1 0;-2 4 -2;0 -1 1]
AUX = zeros(3,3)
for i=0:10
    AUX(3,3) = 0.1*i
    //disp(i)
    //disp(AUX)
    raices = spec(A+AUX)
    disp(raices)
end

Resultado:

   5.  
   1.  
   0.  

   5.0102088  
   1.0518401  
   0.0379511  

   5.0208508  
   1.1071946  
   0.0719546  

   5.0319506  
   1.1657664  
   0.102283  

   5.0435344  
   1.2272145  
   0.1292512  

   5.0556299  
   1.2911771  
   0.153193  

   5.0682668  
   1.3572923  
   0.1744409  

   5.0814764  
   1.4252116  
   0.193312  

   5.0952921  
   1.4946092  
   0.2100986  

   5.1097493  
   1.5651862  
   0.2250644  

   5.1248854  
   1.6366718  
   0.2384428  

 ii)

   5.  
   1.  
   0.  

   5.0102088  
   0.0379511  
   1.0518401  

   5.0208508  
   0.0719546  
   1.1071946  

   5.0319506  
   0.102283  
   1.1657664  

   5.0435344  
   0.1292512  
   1.2272145  

   5.0556299  
   0.153193  
   1.2911771  

   5.0682668  
   0.1744409  
   1.3572923  

   5.0814764  
   0.193312  
   1.4252116  

   5.0952921  
   0.2100986  
   1.4946092  

   5.1097493  
   0.2250644  
   1.5651862  

   5.1248854  
   0.2384428  
   1.6366718  
*/

//4

// a)

function circ(r,x,y)
    xarc(x-r,y+r,2*r,2*r,0,360*64)
endfunction

// b)

// Dibuja todos los circulos de Gershgorin de una matriz real
// cuadrada.

function rectangulo = gers(A)
    dim = size(A,"r")
    radios = zeros(dim,1)   //inicializo acumuladores
    for i=1:dim
        for j=1:dim
            if i <> j then
                radios(i) = radios(i) + abs(A(i,j))
            end
        end
        centros(i) = A(i,i) //tomo las diagonales como los centros
    end
    
    // estimamos el tamaño del "lienzo" para que los 
    //circulos entren cómodamente y se puedan apreciar
    //correctamente (y no cortados)
    
    //esquina inferior izquierda
    
    min_x = round (min(centros - radios)-1)
    min_y = round (min(-radios)-1)
    
    // esquina superior derecha
    
    max_x = round(max(centros+radios)+1)
    max_y = round(max(radios)+1)
    
    rectangulo = [min_x min_y max_x max_y]
    plot2d(0,0,-1,"031"," ",rectangulo,axesflag=1)
    xset("color",11)
    for i=1:dim
        circ(radios(i),centros(i),0)
    end
endfunction

//c) Dibuja los círculos de Gershgorin de una matriz y sus autovalores

function CircGersValor(A)
    rectangulo = gers(A)
    autovalores = spec(A)   //autovalores
    disp(autovalores)
    partes_reales = real(autovalores)
    partes_imaginarias = imag(autovalores)
    xpoly(partes_reales,partes_imaginarias,"marks") //agrego los puntos
    e=gce();
    set(e,"mark_style",3);  
    
endfunction

// 5)

// a)

//Metodo de las potencias para encontrar el autovalor dominante y su correspondiente autovector asociado partiendo del vector arbitrario z0.
function [autovectorAsoc, autovalorDom] = metodoPotencias(z0, A, eps, maxIter)
    iter = 0
    //Primera iteracion del método
    w = A * z0
    autovectorAsoc = w/norm(w,%inf)
    
    [maxElem,k] = max(w)

    autovalorDom = maxElem/autovectorAsoc(k)
    //utilizo la norma infinito entre la diferencia del z0 actual y el autovector asociado y un numero maximo de iteraciones como condicion de para
    while ((iter < maxIter) && norm(autovectorAsoc-z0,%inf) > eps)
        z0 = autovectorAsoc
        w = A * z0
        autovectorAsoc = w/norm(w,%inf)
        
        [maxElem,k] = max(w)
    
        autovalorDom = maxElem/autovectorAsoc(k)
        iter = iter + 1
    end
    
    disp(iter)
endfunction

/*
--> [vector, lambda] = metodoPotencias([1 1 0 0]', A1, 0.0001,1000)

   9.
 lambda  = 

   14.999492

 vector  = 

   1.
   1.
   0.9999661
   0.9999661

--> spec(A1)
 ans  =

  -1.
   5.
   5.
   15.
   
--> [vector, lambda] = metodoPotencias([1 1 0 0]', A2, 0.0001,1000)

   13.
 lambda  = 

   14.247194

 vector  = 

   1.
   0.1779379
   0.3176653
   0.2790048
   
--> spec(A2)
 ans  =

  -6.7748448
   2.1708586
   6.3569501
   14.247036
*/


//b)


function [autovectorAsoc, autovalorDom, diferencias,iter] = metodoPotenciasDiferencias(z0, A, eps, maxIter)
    iter = 1
    
    autovalores = spec(A)
    [_,m] = max(abs(autovalores))
    valorRealAutovalor = autovalores(m)


    w = A * z0
    autovectorAsoc = w/norm(w,%inf)
    
    [maxElem,k] = max(w)
    autovalorDom = maxElem/autovectorAsoc(k)
    
    diferencias(1) = valorRealAutovalor - autovalorDom
    
    while ((iter < maxIter) && norm(autovectorAsoc-z0,%inf) > eps)
        z0 = autovectorAsoc
        w = A * z0
        autovectorAsoc = w/norm(w,%inf)
        
        [maxElem,k] = max(w)
    
        autovalorDom = maxElem/autovectorAsoc(k)
        diferencias(iter+1) = valorRealAutovalor - autovalorDom
        iter = iter + 1
    end
    
    //disp(iter)
endfunction
A1 = [6 4 4 1;4 6 1 4;4 1 6 4;1 4 4 6]
/*
--> A1 = [6 4 4 1;4 6 1 4;4 1 6 4;1 4 4 6]
 A1  = 

   6.   4.   4.   1.
   4.   6.   1.   4.
   4.   1.   6.   4.
   1.   4.   4.   6.
   
--> [v1, lambda1, restas1, nroIter] = metodoPotenciasDiferencias([1 1 0 0]', A1, 0.0001, 1000)
 nroIter  = 

   9.

 restas1  = 

   5.
   2.5
   1.
   0.3571429
   0.1219512
   0.0409836
   0.0136986
   0.0045704
   0.0015239
   0.000508

 lambda1  = 

   14.999492

 v1  = 

   1.
   1.
   0.9999661
   0.9999661

*/
[v1, lambda1, restas1, nroIter1] = metodoPotenciasDiferencias([1 1 0 0]', A1, 0.0001, 1000)

//Graficamos el número de iteraciones en funcion del error de cada aproximación del autovalor respecto al valor real. 

//plot([1:nroIter1],restas1)

/*
--> A2 = [12 1 3 4;1 -3 1 5;3 1 6 -2;4 5 -2 -1]
 A2  = 

   12.   1.   3.   4.
   1.   -3.   1.   5.
   3.    1.   6.  -2.
   4.    5.  -2.  -1.

*/
A2 = [12 1 3 4;1 -3 1 5;3 1 6 -2;4 5 -2 -1]
[v2, lambda2, restas2, nroIter2] = metodoPotenciasDiferencias([1 1 0 0]', A2, 0.0001, 1000)

//plot([1:nroIter2],restas2)

//Podemos observar que cuando n se incrementa, la diferencia entre el valor calculado en la iteración y el valor real se acerca a 0.
//En el primer grafico, las diferencias son siempre positivas, y en el segundo, se va intercalando entre diferencias positivas y negativas. Pero, en ambos casos la diferencia va acercándose a 0 a medida que el número de iteraciones va aumentando.

